\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}
\tikzset{
->, % makes the edges directed
>=stealth, % makes the arrow heads bold
node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

\title{\large Theory of Computation \\ \LARGE Myhill-Nerode Theorem}
\author{Mayank Yadav}
\date{February 9, 2025}

\begin{document}
\maketitle


\section{Introduction}
Myhill-Nerode theorem is a powerful tool that can be used to prove that a language is regular, furthermore it helps in building an algorithm that can be used to minimise a DFA(Deterministic Finite Automata). 

Let there be two strings $x$ and $y$, and a language $L$. The strings $x$ and $y$ are said to be Nerode congruent or related by $\sim_L$ if there doesn't exist any string $z$ that we can concatenate at the end of these such that one ends up in $L$ and one doesn't i.e. mathematically:
$$x \sim_L y \iff \forall z \ (xz \in L \iff yz \in L)$$

$\sim_L$ is an equivalent relation that partition all strings into equivalence classes.

\begin{center}
\fbox{%
    \parbox{0.9\textwidth}{
        Myhill-Nerode theorem states that $\sim_L$ has finite number of equivalence classes(say $k$) iff language $L$ is regular. Furthermore the number of states in minimised DFA is equal to $k$ .
    }
}
\end{center}
The reasoning behind the theorem can be illustrated in the following way:
We know that a language is regular if a DFA can be constructed which accepts every string present in the string and rejects otherwise. In DFA, only the current state matters and the path by which it was achieved doesn't so if strings $x$ and $y$ are at the same state, then $x \sim_L y$ and there is finite number of states in DFA so are the number of equivalent classes.

\section{Minimisation of DFA}

\subsection{Algorithm:}

\begin{algorithm}
\renewcommand{\thealgorithm}{}
\caption{DFA Minimization}\label{alg:cap}
\begin{algorithmic}[1]
    \State Create a lower triangular table to pair every state with every another state. A lower trianglular table is sufficient as they are reflexive.
    \State For each pair ($S_i$,$S_j$), mark it if exactly one of them is final state.
    \State For each unmarked pair ($S_i$,$S_j$), mark it if pair ($\delta(S_i,x),\delta(S_j,x)$) is marked where $\delta$ is transition from one state to another on input $x$ where $x\in \Sigma$ .
    \State Repeat Step 3 until no further changes occur.
    \State Merge all the unmarked pairs. The resulting DFA is the minimised DFA.
\end{algorithmic}
\end{algorithm}

\subsection{Example} \label{sec:minimisation-example}
\begin{figure}[H]
\centering % centers the figure
\begin{tikzpicture}
\node[state, initial] (A) {$A$};
\node[state, above of=A] (B) {$B$};
\node[state, accepting, right of=A] (E) {$E$};
\node[state, above of=E] (C) {$C$};
\node[state, right of=E] (D) {$D$};
\draw (A) edge[left] node{0} (B)
(A) edge[above] node{1} (C)
(B) edge[above] node{1} (C)
(B) edge[loop above] node{0} (B)
(C) edge[bend left=12,above] node{0} (D)
(C) edge[loop above] node{1} (C)
(D) edge[bend left=12, below] node{1} (C)
(D) edge[above] node{0} (E)
(E) edge[left] node{1} (C)
(E) edge[above] node{0} (A);
\end{tikzpicture}
\caption{DFA}
\label{fig:my_label}
\end{figure}
Step 2:\\
The pairs that should be marked are $(A,E),(B,E),(C,E),(D,E)$
$$
\begin{array}{c|ccccc}
  & A & B & C & D & E  \\
\hline
A &           &  &        &        &               \\
B &           & & &        &            \\
C &           &           &  &  &               \\
D &           &           &           &  &       \\
E & \checkmark          & \checkmark          &   \checkmark        &  \checkmark         &   \\
\end{array}
$$
Step 3:

For pair $(A,B)$:
$$
(\delta(A,0),\delta(B,0))=(B,B) \text{ and } (\delta(A,1),\delta(B,1))=(C,C)
$$

For pair $(A,C)$:
$$
(\delta(A,0),\delta(C,0))=(B,D) \text{ and } (\delta(A,1),\delta(C,1))=(C,C)
$$

For pair $(A,D)$:
$$
(\delta(A,0),\delta(D,0))=(B,E) \text{ and } (\delta(A,1),\delta(D,1))=(C,C)
$$

For pair $(B,C)$:
$$
(\delta(B,0),\delta(C,0))=(B,D) \text{ and } (\delta(B,1),\delta(C,1))=(C,C)
$$

For pair $(B,D)$:
$$
(\delta(B,0),\delta(D,0))=(B,E) \text{ and } (\delta(B,1),\delta(D,1))=(C,C)
$$

For pair $(C,D)$:
$$
(\delta(C,0),\delta(D,0))=(D,E) \text{ and } (\delta(C,1),\delta(D,1))=(C,C)
$$

So now pairs $(A,D),(B,D),(C,D)$ will be marked.
$$
\begin{array}{c|ccccc}
  & A & B & C & D & E  \\
\hline
A &           &  &        &        &               \\
B &           & & &        &            \\
C &           &           &  &  &               \\
D & \checkmark        &  \checkmark         &    \checkmark       &  &       \\
E & \checkmark          & \checkmark          &   \checkmark        &  \checkmark  &   \\
\end{array}
$$
Now pairs $(A,C),(B,C)$ will be marked.
$$
\begin{array}{c|ccccc}
  & A & B & C & D & E  \\
\hline
A &           &  &        &        &               \\
B &           & & &        &            \\
C & \checkmark          &  \checkmark         &  &  &               \\
D & \checkmark        &  \checkmark         &    \checkmark       &  &       \\
E & \checkmark          & \checkmark          &   \checkmark        &  \checkmark  &   \\
\end{array}
$$
Step 5:\\
The remaining unmarked pair is $(A,B)$, so states $A$ and $B$ will merge to a new state $AB$. 

\begin{figure}[H]
\centering % centers the figure
\begin{tikzpicture}
\node[state, initial] (AB) {$AB$};
\node[state, accepting, right of=AB] (E) {$E$};
\node[state, above of=E] (C) {$C$};
\node[state, right of=E] (D) {$D$};
\draw (AB) edge[loop above] node{0} (AB)
(AB) edge[above] node{1} (C)
(C) edge[bend left=12,above] node{0} (D)
(C) edge[loop above] node{1} (C)
(D) edge[bend left=12, below] node{1} (C)
(D) edge[above] node{0} (E)
(E) edge[left] node{1} (C)
(E) edge[above] node{0} (AB);
\end{tikzpicture}
\caption{Minimised DFA}
\label{fig:my_label}
\end{figure}
\subsection{Intuition}
Insights into how this algorithm works and its connection to the Myhill-Nerode theorem can be developed by considering the following:\\
Let there be a language $L$=Set of strings with odd number of $a$s and no $c$s over $\Sigma={a,b,c}.$
Say $w\in L$ and $w=xz$ then the equivalent classes will be:
$$
\begin{array}{|c|c|}
\hline
x & z \\ \hline
\varepsilon, b, aa,\cdots \text{Strings with even number of $a$s and no $c$s} & \text{Strings with an odd numbers of $a$s and no $c$s} \\ \hline
a,ab,\cdots \text{Strings with odd number of $a$s and no $c$s} & \text{Strings with an even number of $a$s and no $c$s} \\ \hline
c,\text{Strings containing c} & \emptyset \\ \hline
\end{array}
$$
and now a DFA can be constructed having $3$ states which accepts this language and it will be having minimal states.

In Section~\ref{sec:minimisation-example} the unmarked pairs$(A,B)$, obtained after recursively marking pairs belong to the same equivalence class, so we could merge them.
Ultimately, the algorithm identifies distinguishable extensions ($z$). For instance, at Step $2$, for $x = \varepsilon$, we find that pair $(A,E)$ is distinguishable because one state accepts it (state $E$) while the other does not (state $A$). At each iteration of Step $3$, distinctions propagate by analyzing transitions on every input symbol. If even one distinguishing extension exists for two states, they cannot be equivalent.


\end{document}

